use crate::DexErrorError::InvalidArithmeticOperation;
use anchor_lang::prelude::*;

declare_id!("9EqVh33gZ9Q2rG5kSyWWrMAvKgrXakoPXavPZucqQ3P8");

#[program]
pub mod dex_exchange {
    use super::*;

    pub fn initialize_pool(
        ctx: Context<InitializePool>,
        token_a: Pubkey,
        token_b: Pubkey,
    ) -> Result<()> {
        let pool = &mut ctx.accounts.pool;
        pool.token_a = token_a;
        pool.token_b = token_b;
        pool.reserve_a = 0;
        pool.reserve_b = 0;
        Ok(())
    }

    pub fn add_liquidity(ctx: Context<AddLiquidity>, amount_a: u64, amount_b: u64) -> Result<()> {
        let pool = &mut ctx.accounts.pool;
        let user = &ctx.accounts.user;

        // Transfer tokens from user to pool
        /*
        let token_a_reserve = pool.reserve_a + amount_a;
        let token_b_reserve = pool.reserve_b + amount_b;

        pool.reserve_a = token_a_reserve;
        pool.reserve_b = token_b_reserve;
        */

        let token_a_reserve = pool.reserve_a;
        let token_b_reserve = pool.reserve_b;

        // Increment reserve_a with amount_a
        pool.reserve_a = token_a_reserve
            .checked_add(amount_a)
            .ok_or(InvalidArithmeticOperation)?; // DexError::InvalidArithmeticOperation

        // Increment reserve_b with amount_b
        pool.reserve_b = token_b_reserve
            .checked_add(amount_b)
            .ok_or(InvalidArithmeticOperation)?;

        // Issue LP tokens or similar mechanism can be implemented here.
        Ok(())
    }

    pub fn swap(ctx: Context<Swap>, amount_in: u64, token_in: Pubkey) -> Result<()> {
        let pool = &mut ctx.accounts.pool;
        let user = &ctx.accounts.user;
        let token_a_reserve = pool.reserve_a;
        let token_b_reserve = pool.reserve_b;
        let mut is_token_a = false;

        // Determine the token being swapped and adjust reserves accordingly
        let (reserve_in, reserve_out) = if token_in == pool.token_a {
            //(&mut pool.reserve_a, &mut pool.reserve_b)
            is_token_a = true;
            (token_a_reserve, token_b_reserve)
        } else {
            //(&mut pool.reserve_b, &mut pool.reserve_a)
            (token_b_reserve, token_a_reserve)
        };

        //let amount_out = (*reserve_out * amount_in) / (*reserve_in + amount_in); // Simplified AMM calculation
        let amount_out = (reserve_out * amount_in) / (reserve_in + amount_in); // Simplified AMM calculation

        /*
         *reserve_in += amount_in;
         *reserve_out -= amount_out;
         */

        if is_token_a {
            // Increment reserve_a with amount
            pool.reserve_a = token_a_reserve
                .checked_add(amount_in)
                .ok_or(InvalidArithmeticOperation)?;

            // Decrement reserve_b with amount
            pool.reserve_b = token_b_reserve
                .checked_sub(amount_out)
                .ok_or(InvalidArithmeticOperation)?;
        } else {
            // Increment reserve_b with amount
            pool.reserve_b = token_b_reserve
                .checked_add(amount_in)
                .ok_or(InvalidArithmeticOperation)?;

            // Decrement reserve_a with amount
            pool.reserve_a = token_a_reserve
                .checked_sub(amount_out)
                .ok_or(InvalidArithmeticOperation)?;
        }

        // Transfer tokens
        Ok(())
    }
}

#[derive(Accounts)]
pub struct InitializePool<'info> {
    #[account(init, payer = user, space = 8 + Pool::INIT_SPACE,)]
    pub pool: Account<'info, Pool>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct AddLiquidity<'info> {
    #[account(mut)]
    pub pool: Account<'info, Pool>,
    #[account(mut)]
    pub user: Signer<'info>,
}

#[derive(Accounts)]
pub struct Swap<'info> {
    #[account(mut)]
    pub pool: Account<'info, Pool>,
    #[account(mut)]
    pub user: Signer<'info>,
}

#[account]
#[derive(InitSpace)]
pub struct Pool {
    pub token_a: Pubkey,
    pub token_b: Pubkey,
    pub reserve_a: u64,
    pub reserve_b: u64,
}

#[error_code]
pub enum DexErrorError {
    // Arithmetic
    #[msg("Arithmetic operation failed.")]
    InvalidArithmeticOperation,
}
